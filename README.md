# 策略模式代码说明
在策略模式的案例中，高阶版有运用：工厂模式 + 模版方法作为辅助，来说明策略在工作中的优美使用方式。

### 结构说明
- pay 业务代码
- strategy_pattern 策略模式包
  - controller 控制层代码
  - service 业务实现层代码
    - original 不使用策略模式，使用传统if-else方式实现
    - strategy 使用策略模式
      - v1 只使用策略模式，通过List<IPayStrategyV1Service>注入的模式，将多个实现类注入，然后在Controller层获取不同实现类完成策略
      - v2 策略模式的高阶用法
        - handler 使用 策略模式 + 工厂模式
        - abstractHandler 使用 策略模式 + 工厂模式 + 模版模式，用于处理策略模式中可能存在的不同调用逻辑

### 详细说明
#### 一、传统if-else方式实现
在 original 包下，使用的是if-else方式实现，该方式不满足开闭原则（对修改关闭，对扩展开放），每次新增一个支付通道的情况下都需要修改支付实现的
方法，需要修改if-else代码， 这样当代码很多或者支付渠道很多的情况：
- 代码会显得特别臃肿
- 修改的时候可能会存在误修改原有代码的情况
- 测试的同事也很难进行抉择，是需要全部回归测试还是只测试新增需求，如何保证你的修改没有修改到原本上心的功能

#### 二、简单策略模式
在 strategy-v1 的包下，使用的是简单策略模式，通过 List<IPayStrategyV1Service> 注入的模式，将多个实现类注入，然后在Controller层获取不
同实现类完成策略，如果新增 支付通道，只需要新增一种策略类实现接口，完成该类的相应方法即可，该方式不需要需改原有支付渠道的代码

#### 三、策略模式 + 工厂方法
在 strategy-v2 的包下，使用的是策略模式 + 工厂方法来完成策略的自动路由，其中策略接口需要实现spring的InitializingBean，目的是为了在策略实
现类的方法中，会要求实现InitializingBean接口的afterPropertiesSet()方法，通过该方法将自己注册到工厂中，这样在控制层就可以直接通过工厂获取
对应的策略实现方法。

#### 四、策略模式 + 工厂方法 + 模版方法
在策略模式 + 工厂方法的形式下，如果存在不同的策略下调用的方法不一致的情况，比如：所有支付通用的方法都是pay(),但是新增的渠道工商银行支付需要调
用方法A(), 建设银行支付需要调用B()方法，在这种情况下A(),B()如果写到策略接口PayStrategyHandler中，那么所有实现PayStrategyHandler的实现
类都需要实现 A(),B()两个方法（空实现），这样同样破坏了开闭原则，需要对原本的实现类进行修改。
所以此时需要通过模版模式，来避免对所有实现类的修改。

